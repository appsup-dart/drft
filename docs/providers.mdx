# Provider Development Guide

Providers are plugins that enable DRFT to manage resources on different platforms. This guide explains how to create custom providers.

## Provider Interface

All providers must implement the `Provider` interface:

```dart
abstract class Provider {
  String get name;
  String get version;
  
  Future<void> configure(Map<String, dynamic> config);
  Future<ResourceState> createResource(Resource resource);
  Future<ResourceState> readResource(String resourceId, String resourceType);
  Future<ResourceState> updateResource(
    ResourceState current,
    Resource desired,
  );
  Future<void> deleteResource(ResourceState state);
  bool canHandle(Resource resource);
  Future<void> initialize();
  Future<void> dispose();
}
```

## Creating a Provider

### Step 1: Implement Provider

```dart
import 'package:drft/drft.dart';

class MyCloudProvider extends Provider {
  MyCloudProvider({
    required String region,
    String? apiKey,
  }) : _region = region,
       _apiKey = apiKey,
       super(
         name: 'mycloud',
         version: '1.0.0',
       );
  
  final String _region;
  final String? _apiKey;
  MyCloudClient? _client;
  
  @override
  Future<void> configure(Map<String, dynamic> config) async {
    _client = MyCloudClient(
      region: config['region'] ?? _region,
      apiKey: config['apiKey'] ?? _apiKey,
    );
  }
  
  @override
  Future<void> initialize() async {
    await _client?.connect();
  }
  
  @override
  Future<void> dispose() async {
    await _client?.disconnect();
  }
  
  @override
  bool canHandle(Resource resource) {
    return resource.type.startsWith('mycloud.');
  }
}
```

### Step 2: Implement Resource Operations

```dart
@override
Future<ResourceState> createResource(Resource resource) async {
  if (resource is VirtualMachine) {
    return await _createVirtualMachine(resource);
  } else if (resource is Database) {
    return await _createDatabase(resource);
  }
  throw UnsupportedResourceTypeException(resource.type);
}

Future<ResourceState> _createVirtualMachine(VirtualMachine vm) async {
  final response = await _client!.createVM(
    name: vm.name,
    image: vm.image,
    size: vm.size,
    region: _region,
  );
  
  return ResourceState(
    resourceId: response.id,
    resourceType: 'mycloud.vm',
    properties: {
      'name': vm.name,
      'image': vm.image,
      'size': vm.size,
      'ip': response.ipAddress,
    },
    metadata: {
      'createdAt': DateTime.now().toIso8601String(),
    },
  );
}

@override
Future<ResourceState> readResource(
  String resourceId,
  String resourceType,
) async {
  if (resourceType == 'mycloud.vm') {
    final vm = await _client!.getVM(resourceId);
    return ResourceState(
      resourceId: vm.id,
      resourceType: resourceType,
      properties: {
        'name': vm.name,
        'image': vm.image,
        'size': vm.size,
        'ip': vm.ipAddress,
      },
    );
  }
  throw UnsupportedResourceTypeException(resourceType);
}

@override
Future<ResourceState> updateResource(
  ResourceState current,
  Resource desired,
) async {
  // Compare current and desired states
  // Make API calls to update only what changed
  // Return new state
}

@override
Future<void> deleteResource(ResourceState state) async {
  await _client!.deleteVM(state.resourceId);
}
```

## Example: AWS Provider

```dart
class AwsProvider extends Provider {
  AwsProvider({
    required String region,
    AwsCredentials? credentials,
  }) : _region = region,
       _credentials = credentials,
       super(name: 'aws', version: '1.0.0');
  
  final String _region;
  final AwsCredentials? _credentials;
  late AwsClient _client;
  
  @override
  Future<void> configure(Map<String, dynamic> config) async {
    _client = AwsClient(
      region: config['region'] ?? _region,
      credentials: config['credentials'] ?? _credentials,
    );
  }
  
  @override
  Future<ResourceState> createResource(Resource resource) async {
    switch (resource.type) {
      case 'aws.ec2.instance':
        return await _createEC2Instance(resource as EC2Instance);
      case 'aws.rds.database':
        return await _createRDSDatabase(resource as RDSDatabase);
      case 'aws.s3.bucket':
        return await _createS3Bucket(resource as S3Bucket);
      default:
        throw UnsupportedResourceTypeException(resource.type);
    }
  }
  
  Future<ResourceState> _createEC2Instance(EC2Instance instance) async {
    final response = await _client.ec2.runInstances(
      imageId: instance.imageId,
      instanceType: instance.instanceType,
      subnetId: instance.subnetId,
      securityGroupIds: instance.securityGroupIds,
      tags: instance.tags,
    );
    
    return ResourceState(
      resourceId: response.instanceId,
      resourceType: 'aws.ec2.instance',
      properties: {
        'instanceId': response.instanceId,
        'publicIp': response.publicIp,
        'privateIp': response.privateIp,
      },
    );
  }
  
  // ... other methods
}
```

## Example: Kubernetes Provider

```dart
class KubernetesProvider extends Provider {
  KubernetesProvider({
    required String kubeconfig,
    String? namespace,
  }) : _kubeconfig = kubeconfig,
       _namespace = namespace ?? 'default',
       super(name: 'kubernetes', version: '1.0.0');
  
  final String _kubeconfig;
  final String _namespace;
  late KubernetesClient _client;
  
  @override
  Future<void> configure(Map<String, dynamic> config) async {
    _client = KubernetesClient.fromConfig(
      config['kubeconfig'] ?? _kubeconfig,
    );
  }
  
  @override
  Future<ResourceState> createResource(Resource resource) async {
    if (resource is KubernetesDeployment) {
      return await _createDeployment(resource);
    } else if (resource is KubernetesService) {
      return await _createService(resource);
    }
    throw UnsupportedResourceTypeException(resource.type);
  }
  
  Future<ResourceState> _createDeployment(
    KubernetesDeployment deployment,
  ) async {
    final k8sDeployment = V1Deployment()
      ..metadata = (V1ObjectMeta()
        ..name = deployment.name
        ..namespace = _namespace)
      ..spec = (V1DeploymentSpec()
        ..replicas = deployment.replicas
        ..selector = V1LabelSelector()
        ..template = V1PodTemplateSpec());
    
    final created = await _client.appsV1.createNamespacedDeployment(
      _namespace,
      k8sDeployment,
    );
    
    return ResourceState(
      resourceId: '${_namespace}/${deployment.name}',
      resourceType: 'kubernetes.deployment',
      properties: {
        'name': deployment.name,
        'namespace': _namespace,
        'replicas': deployment.replicas,
      },
    );
  }
}
```

## Error Handling

Providers should handle errors gracefully:

```dart
@override
Future<ResourceState> createResource(Resource resource) async {
  try {
    // ... create resource
  } on MyCloudApiException catch (e) {
    throw ProviderException(
      'Failed to create resource: ${e.message}',
      provider: name,
      resourceType: resource.type,
      originalError: e,
    );
  } on TimeoutException catch (e) {
    throw ProviderException(
      'Timeout creating resource',
      provider: name,
      resourceType: resource.type,
      originalError: e,
    );
  }
}
```

## Testing Providers

Use mock clients for testing:

```dart
class MockMyCloudClient implements MyCloudClient {
  final Map<String, dynamic> _vms = {};
  
  @override
  Future<CreateVMResponse> createVM({
    required String name,
    required String image,
    required String size,
    required String region,
  }) async {
    final id = 'vm-${DateTime.now().millisecondsSinceEpoch}';
    _vms[id] = {
      'id': id,
      'name': name,
      'image': image,
      'size': size,
      'ip': '10.0.0.1',
    };
    return CreateVMResponse(id: id, ipAddress: '10.0.0.1');
  }
  
  @override
  Future<VM> getVM(String id) async {
    if (!_vms.containsKey(id)) {
      throw VMNotFoundException(id);
    }
    final data = _vms[id]!;
    return VM(
      id: data['id'],
      name: data['name'],
      image: data['image'],
      size: data['size'],
      ipAddress: data['ip'],
    );
  }
}
```

## Provider Registration

Providers can be registered in several ways:

1. **Built-in**: Included in DRFT core
2. **Package**: Published as a separate package
3. **Local**: Loaded from local files

```dart
// Load provider from package
final provider = await ProviderLoader.loadFromPackage('drft_aws');

// Load provider from file
final provider = await ProviderLoader.loadFromFile('lib/providers/my_provider.dart');
```

## Best Practices

1. **Idempotency**: Operations should be idempotent
2. **Error Messages**: Provide clear, actionable error messages
3. **Retry Logic**: Implement retry logic for transient failures
4. **Rate Limiting**: Respect API rate limits
5. **Connection Pooling**: Reuse connections when possible
6. **Logging**: Log all operations for debugging
7. **Validation**: Validate resource properties before API calls

